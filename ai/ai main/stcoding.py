#!/usr/bin/env python3

import re
import time
import uuid
import asyncio
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

class CodeBlockState(Enum):
    OUTSIDE = "outside"
    STARTING = "starting"
    INSIDE = "inside"
    ENDING = "ending"

@dataclass
class CodeBlock:
    id: str
    language: str
    content: str = ""
    complete: bool = False
    started_at: float = field(default_factory=time.time)
    ended_at: Optional[float] = None
    line_count: int = 0
    character_count: int = 0

    def update_stats(self):
        """Update line and character counts"""
        self.line_count = len(self.content.split('\n'))
        self.character_count = len(self.content)

    def add_content(self, content: str):
        """Add content to the code block"""
        self.content += content
        self.update_stats()

    def finalize(self, ended_at: Optional[float] = None):
        """Mark the code block as complete"""
        self.complete = True
        self.ended_at = ended_at or time.time()

class CodeBlockTracker:
    """
    Advanced code block tracking for streaming AI responses.
    Tracks code blocks in real-time as they are generated by the AI.
    """
    
    def __init__(self):
        self.blocks: Dict[str, CodeBlock] = {}
        self.current_block: Optional[CodeBlock] = None
        self.state: CodeBlockState = CodeBlockState.OUTSIDE
        self.pending_language: Optional[str] = None
        self.buffer: str = ""
        self.current_block_id: Optional[str] = None
        self.code_block_count: int = 0
        self.in_code_block: bool = False
        
        # Code block detection patterns
        self.fence_pattern = re.compile(r'```(\w*)')
        self.language_pattern = re.compile(r'^```(\w+)\s*$')
        
        # Statistics
        self.total_code_chars = 0
        self.total_code_lines = 0
        self.start_time = time.time()
    
    def process_token(self, token: str) -> Dict[str, Any]:
        """
        Process a single token and track code blocks.
        Returns a dictionary with tracking information.
        """
        result = {
            'text': token,
            'in_code': self.in_code_block,
            'code_block_started': False,
            'code_block_id': None,
            'code_language': None,
            'streaming_code': None,
            'code_block': None
        }
        
        # Add token to buffer for pattern matching
        self.buffer += token
        
        # Look for code fence patterns in the buffer
        self._scan_buffer()
        
        # Process the token based on current state
        if self.current_block:
            self.current_block.add_content(token)
            result['streaming_code'] = {
                'id': self.current_block_id,
                'language': self.current_block.language,
                'code': token,
                'complete': False
            }
            self.total_code_chars += len(token)
            
        return result
    
    def _scan_buffer(self):
        """Scan the buffer for code fence patterns"""
        lines = self.buffer.split('\n')
        
        for i, line in enumerate(lines):
            if self.state == CodeBlockState.OUTSIDE:
                # Look for code block start
                match = self.language_pattern.match(line.strip())
                if match:
                    self._start_code_block(match.group(1), line)
                    # Clear the processed line from buffer
                    self.buffer = '\n'.join(lines[i+1:])
                    break
                    
            elif self.state == CodeBlockState.INSIDE:
                # Look for code block end
                if line.strip() == '```':
                    self._end_code_block(line)
                    # Clear the processed line from buffer
                    self.buffer = '\n'.join(lines[i+1:])
                    break
    
    def _start_code_block(self, language: str, line: str):
        """Start a new code block"""
        self.code_block_count += 1
        self.current_block_id = f"code_block_{self.code_block_count}_{uuid.uuid4().hex[:8]}"
        self.current_block = CodeBlock(
            id=self.current_block_id,
            language=language or "text"
        )
        self.blocks[self.current_block_id] = self.current_block
        self.state = CodeBlockState.INSIDE
        self.in_code_block = True
        
        # Calculate content that comes after the fence
        remaining_content = line[len(line.rstrip()) + 1:] if line.strip() != line else ""
        if remaining_content.strip():
            self.current_block.add_content(remaining_content)
        
        # Return start information
        self._last_result.update({
            'code_block_started': True,
            'code_block_id': self.current_block_id,
            'code_language': language or "text"
        })
    
    def _end_code_block(self, line: str):
        """End the current code block"""
        if self.current_block:
            # Add any remaining content before the fence
            parts = line.split('```', 1)
            if len(parts) > 1 and parts[0].strip():
                self.current_block.add_content(parts[0])
            
            self.current_block.finalize()
            self.current_block_id = None
            self.state = CodeBlockState.OUTSIDE
            self.in_code_block = False
            
            # Return complete block information
            result = {
                'id': self.current_block.id,
                'language': self.current_block.language,
                'code': self.current_block.content,
                'complete': True,
                'line_count': self.current_block.line_count,
                'character_count': self.current_block.character_count,
                'duration': self.current_block.ended_at - self.current_block.started_at
            }
            
            self._last_result['code_block'] = result
            self._last_result['streaming_code'] = result
            
            # Clean up
            self.current_block = None
            self.buffer = ""
    
    def finalize(self) -> Dict[str, Any]:
        """
        Finalize tracking and return summary statistics.
        """
        # Finalize any open code block
        if self.current_block:
            self.current_block.finalize()
        
        total_duration = time.time() - self.start_time
        
        # Calculate total statistics
        total_blocks = len(self.blocks)
        total_lines = sum(block.line_count for block in self.blocks.values())
        total_chars = sum(block.character_count for block in self.blocks.values())
        
        return {
            'code_blocks': [
                {
                    'id': block.id,
                    'language': block.language,
                    'content': block.content,
                    'complete': block.complete,
                    'line_count': block.line_count,
                    'character_count': block.character_count,
                    'duration': block.ended_at - block.started_at if block.ended_at else None
                }
                for block in self.blocks.values()
            ],
            'has_code': total_blocks > 0,
            'statistics': {
                'total_blocks': total_blocks,
                'total_lines': total_lines,
                'total_characters': total_chars,
                'total_duration': total_duration,
                'blocks_per_second': total_blocks / total_duration if total_duration > 0 else 0,
                'lines_per_second': total_lines / total_duration if total_duration > 0 else 0
            },
            'current_state': {
                'in_code_block': self.in_code_block,
                'current_block_id': self.current_block_id,
                'state': self.state.value
            }
        }
    
    def get_current_block(self) -> Optional[CodeBlock]:
        """Get the currently active code block"""
        return self.current_block
    
    def get_block_by_id(self, block_id: str) -> Optional[CodeBlock]:
        """Get a code block by its ID"""
        return self.blocks.get(block_id)
    
    def get_all_blocks(self) -> List[CodeBlock]:
        """Get all code blocks"""
        return list(self.blocks.values())
    
    def is_in_code_block(self) -> bool:
        """Check if currently inside a code block"""
        return self.in_code_block
    
    def get_active_block_info(self) -> Optional[Dict[str, Any]]:
        """Get information about the currently active block"""
        if self.current_block:
            return {
                'id': self.current_block.id,
                'language': self.current_block.language,
                'content': self.current_block.content,
                'line_count': self.current_block.line_count,
                'character_count': self.current_block.character_count,
                'duration': time.time() - self.current_block.started_at
            }
        return None
    
    def reset(self):
        """Reset the tracker to initial state"""
        self.blocks.clear()
        self.current_block = None
        self.state = CodeBlockState.OUTSIDE
        self.pending_language = None
        self.buffer = ""
        self.current_block_id = None
        self.code_block_count = 0
        self.in_code_block = False
        self.total_code_chars = 0
        self.total_code_lines = 0
        self.start_time = time.time()
    
    def get_language_stats(self) -> Dict[str, int]:
        """Get statistics by programming language"""
        lang_counts = {}
        for block in self.blocks.values():
            lang = block.language or "text"
            lang_counts[lang] = lang_counts.get(lang, 0) + 1
        return lang_counts
    
    def get_complexity_score(self) -> float:
        """Calculate a complexity score based on code blocks"""
        if not self.blocks:
            return 0.0
        
        total_lines = sum(block.line_count for block in self.blocks.values())
        total_blocks = len(self.blocks)
        avg_lines_per_block = total_lines / total_blocks if total_blocks > 0 else 0
        
        # Weight different languages differently
        language_weights = {
            'python': 1.2,
            'javascript': 1.1,
            'typescript': 1.3,
            'java': 1.4,
            'cpp': 1.5,
            'csharp': 1.4,
            'rust': 1.6,
            'go': 1.3,
            'python': 1.2
        }
        
        weighted_complexity = 0
        for block in self.blocks.values():
            weight = language_weights.get(block.language.lower(), 1.0)
            weighted_complexity += block.line_count * weight
        
        return weighted_complexity / len(self.blocks)

# Legacy compatibility - create a global instance
code_tracker = CodeBlockTracker()

def create_code_tracker() -> CodeBlockTracker:
    """Create a new code tracker instance"""
    return CodeBlockTracker()

# For backward compatibility with existing imports
CodeBlockTracker = CodeBlockTracker